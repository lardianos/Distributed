/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

// Calculator Client RPC AND Socket Server

#include "calculator.h"
#include"stdio.h"
#include"stdlib.h"
#include"sys/types.h"
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include"string.h"
#include"netinet/in.h"
#include"netdb.h"
#include"pthread.h"

#define PORT 45227
#define BUF_SIZE 2000
#define CLADDR_LEN 100

struct data_save{
	float a;
	int * Y;
	int n;	
};

struct addres_data{
	struct sockaddr_in addr;
	int len;
	int *newsockfd;
	char * s_host;	
};

typedef struct {
	float a_res;
	int maxmin[2];	
	float *Y;
	int Y_len;
}res_nums_cl ;

res_nums_cl calc_prog_1(char *host, int select,float a_num, int n_num,int * y_table) {
	CLIENT *clnt;
	struct res_nums  *result_1;
	data  average_1_arg;
	struct res_nums  *result_2;
	data  maxmin_1_arg;
	struct res_nums  *result_3;
	data  vectorproduct_1_arg;	
	res_nums_cl ret1;

#ifndef	DEBUG
	clnt = clnt_create (host, CALC_PROG, CALC_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */
	//average_1_arg.Y.Y_len = 0;
	//average_1_arg.n = n_num;
	maxmin_1_arg.Y.Y_len = 0;
	vectorproduct_1_arg.Y.Y_len = 0;	
	if(select ==1 ){
		/*===============Average=====START==============================*/		
		average_1_arg.Y.Y_len = n_num;
		average_1_arg.Y.Y_val = (int *) malloc(n_num*sizeof(int));
		average_1_arg.Y.Y_val = y_table;
		/*for (int i = 0; i < n_num; i++) {
			printf("%d\n",average_1_arg.Y.Y_val[i]);
		}*/
		printf("Call RPC Func 1 (Average)\n");
		result_1 = average_1(&average_1_arg, clnt);
		if (result_1 == (struct res_nums *) NULL) {
			clnt_perror (clnt, "call failed");
		}
		printf("%f\n",result_1->a_res);	
		ret1.a_res = result_1->a_res;
		return ret1;
		/*===============Average=====END================================*/		
	}else if (select == 2){
		/*===============MaxMin==START==================================*/
		printf("Call RPC Func 2 (Max Min)\n");
		maxmin_1_arg.Y.Y_len = n_num;
		maxmin_1_arg.Y.Y_val = (int *) malloc(n_num*sizeof(int));
		maxmin_1_arg.Y.Y_val = y_table;
		result_2 = maxmin_1(&maxmin_1_arg, clnt);
		if (result_2 == (struct res_nums *) NULL) {
			clnt_perror (clnt, "call failed");
		}
		printf("max %d min %d\n",result_2->maxmin[0],result_2->maxmin[1]);
		ret1.maxmin[0] = result_2->maxmin[0];
		ret1.maxmin[1] = result_2->maxmin[1];
		return ret1;
		/*===============MaxMin==END====================================*/
	}else if (select == 3){
		/*===============VectorProduct===START==========================*/
		printf("Call RPC Func 3 (Vector Product)\n");
		vectorproduct_1_arg.Y.Y_len = n_num;
		vectorproduct_1_arg.Y.Y_val = (int *) malloc(n_num*sizeof(int));
		vectorproduct_1_arg.Y.Y_val = y_table;
		vectorproduct_1_arg.a=a_num;
		/*for (int i = 0; i < n_num; i++)	{
			printf("Y = %d \n", vectorproduct_1_arg.Y.Y_val[i]);
		}*/
		result_3 = vectorproduct_1(&vectorproduct_1_arg, clnt);
		if (result_3 == (struct res_nums *) NULL) {
			clnt_perror (clnt, "call failed");
		}
		for (int i = 0; i < result_3->Y.Y_len; i++)	{
			printf("Resault [%d] = [%f]\n",i+1,result_3->Y.Y_val[i]);					
		}
		ret1.Y = result_3->Y.Y_val;
		ret1.Y_len = result_3->Y.Y_len;
		return ret1;
		/*===============VectorProduct===END============================*/
	}
	printf("END\n");
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}

void * reciveMessage(void * cli_data){
	struct data_save data;
	struct addres_data * local_address_data = cli_data;
	int sockfd, ret;
	int flag_select_Average = 0,flag_select_MaxMin = 0,flag_select_VectorProduct = 0;
	int flag_select_Menu = 1;
	int i_test=0;
	char buffer[BUF_SIZE];
	char temp[BUF_SIZE];
	sockfd=*((int*)local_address_data->newsockfd);
	memset(buffer,0,BUF_SIZE);
	printf("\n");
	int a_num =1,select=-1,n_num=0;
	int *y_table;
	res_nums_cl ret1;
	/*ret=sendto(sockfd," Hello Client ",strlen(" Hello Client "),0,(struct sockaddr *)&local_address_data->addr,local_address_data->len);
	if(ret<0){
			printf("Error sending data!\n");
		exit(1);
	}*/
	while(1){
		memset(buffer,0,BUF_SIZE);
		ret=recvfrom(sockfd,buffer,BUF_SIZE,0,NULL,NULL);	
		if (ret < 0) {  
			printf("Error receiving data!\n");    
		}
		//===========Diavasma tou N===========================================
		if (buffer[0] == '0'){
			printf("END\n");
			//exit(0);
			//pthread_exit(NULL);
			return(void *)"END";
		}
		puts(buffer);
		int i=2,j=0;
		for (i,j; i < strlen(buffer); i++,j++) {
			if (buffer[i] == ';'||buffer[i] == '\n'||buffer[i] == '\0'){
				break;
			}else{
				temp[j] = buffer[i];
			}
		}
		i++;
		data.n = atoi(temp);
		data.Y = (int *) malloc(data.n*sizeof(int));
		memset(temp,0,BUF_SIZE);
		puts(temp);
		printf("meta memset %d %d\n",j,i );

		//===========Diavasma ton stixion tou Y==============================
		j=0;
		int k=0;
		puts(buffer);

		for (i; i < strlen(buffer); i++) {
			printf("char [%c] Epanalipsi [%d] \n",buffer[i],i);
			if (buffer[i] == ';'||buffer[i] == '\n'||buffer[i] == '\0'){
				break;
			}else if(buffer[i] != ','){
				temp[j] = buffer[i];
				j++;
			}
			if (buffer[i+1]==',' || buffer[i+1]=='\n' || buffer[i+1]=='\0' || buffer[i+1]==';' ){			
				data.Y[k] = atoi(temp);
				memset(temp,0,BUF_SIZE);
				j=0;
				k++;
			}
		}
		printf("data[i].Y \n");
		for (int i = 0; i < data.n; i++){
			printf("%d,",data.Y[i]);
		}
		printf("\n");
		//===========Diavasma ton stixion tou Y==============================
		if (buffer[0] == '1'){
			select = (int) (buffer[0]-'0');						
			ret1 =calc_prog_1 (local_address_data->s_host,select,a_num,data.n,data.Y);
			memset(temp,0,BUF_SIZE);
			ret = sprintf(temp, "%.2f", ret1.a_res);
			if (ret < 0) {
				printf("Error converting float to string\n");
	    		exit(1);
			}
			ret=sendto(sockfd,temp,strlen(temp),0,(struct sockaddr *)&local_address_data->addr,local_address_data->len);
			if(ret<0){
				printf("Error sending data!\n");
				exit(1);
			}
		}else if(buffer[0] == '2') {		
			select = (int) (buffer[0]-'0');
			ret1 = calc_prog_1 (local_address_data->s_host,select,a_num,data.n,data.Y);

			memset(temp,0,BUF_SIZE);
			memset(buffer,0,BUF_SIZE);
			strcat(buffer,"Max = ");
			ret = sprintf(temp, "%d", ret1.maxmin[0]);
			if (ret < 0) {
				printf("Error converting integer to string\n");
	    		exit(1);
			}
			strcat(buffer,temp);
			memset(temp,0,BUF_SIZE);

			strcat(buffer," Min = ");
			ret = sprintf(temp, "%d", ret1.maxmin[1]);
			if (ret < 0) {
				printf("Error converting integer to string\n");
	    		exit(1);
			}
			strcat(buffer,temp);

			ret=sendto(sockfd,buffer,strlen(buffer),0,(struct sockaddr *)&local_address_data->addr,local_address_data->len);
			if(ret<0){
				printf("Error sending data!\n");
				exit(1);
			}
		}else if (buffer[0] == '3') {
			select = (int) (buffer[0]-'0');	
			i++;
			memset(temp,0,BUF_SIZE);		
			//printf("meta memset %d %d\n",j,i );
			j=0;
			int k=0;
			for (i; i < strlen(buffer); i++) {							
				printf("char [%c] Epanalipsi [%d]\n",buffer[i],i);
				if (buffer[i] == ';'||buffer[i] == '\n'||buffer[i] == '\0'){
					break;
				}
				//printf("xaraktiras %d = %c kai j=%d\n",i,buffer[i],j );
				temp[j] = buffer[i];
				//printf("temp = ");
				puts(temp);
				j++;						
			}
			data.a = atof(temp);
			printf("data.a = [%f]\n",data.a);
			printf("data.n = [%d]\n",data.n);
			for (int i = 0; i < data.n; ++i)	{
				printf("data.Y[%d] = [%d]\n",i,data.Y[i]);
			
			}
			printf("====Call calc_prog_1=====\n");
			ret1 = calc_prog_1 (local_address_data->s_host,select,data.a,data.n,data.Y);
			printf("====End calc_prog_1======\n");
			printf("====Start Resault======\n");
			for (int i = 0; i < data.n; ++i)
			{
				printf("Resault [%d] = [%f]\n",i+1,ret1.Y[i]);
			}
			printf("====End Resault======\n");
			memset(temp,0,BUF_SIZE);
			memset(buffer,0,BUF_SIZE);
			strcat(buffer,"Vector Product =  ");
			for (int i = 0; i < data.n; ++i)
			{
				printf("Resault [%d] = [%f]\n",i+1,ret1.Y[i]);
				sprintf(temp, "%f", ret1.Y[i]);
				strcat(buffer,temp);
				memset(temp,0,BUF_SIZE);
				strcat(buffer,",");
			}
			ret=sendto(sockfd,buffer,strlen(buffer),0,(struct sockaddr *)&local_address_data->addr,local_address_data->len);
			if(ret<0){
				printf("Error sending data!\n");
				exit(1);
			}
		}
	}	
}

int main (int argc, char *argv[]) {
	//Socet===Variables======Start=========================

	struct addres_data cl_data;
	struct sockaddr_in addr, cl_addr;
	int sockfd,len,ret,newsockfd;
	int yes=1;
	char buffer[BUF_SIZE];
	char clientAddr[CLADDR_LEN];
	pthread_t rThread;
	//Socet===Variables======END===========================
	//RPC====Variables=======Start=========================
	int select,n_num;
	int y_table[] = {1,7,6}; 
	char *host;
	float a_num;
	//RPC====Variables=======End==========================	
	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	//=====================================================
	sockfd=socket(AF_INET,SOCK_STREAM,0);
	if(sockfd<0){
		printf("Error creating socket\n");
		exit(1);
	}
	if(setsockopt(sockfd,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(int))==-1){
		perror("setsockopt");
		exit(1);
	}
	printf("Socket created...\n");

	memset(&addr,0,sizeof(addr));
	addr.sin_family =AF_INET;
	addr.sin_addr.s_addr=INADDR_ANY;
	addr.sin_port=PORT;

	ret=bind(sockfd,(struct sockaddr *)&addr, sizeof(addr));
	if(ret<0){
		printf("Error binding!\n");
		exit(1);
	}
	printf("Binding done..");
	printf("waiting for a connection ...\n");
	listen(sockfd,5);

	len = sizeof(struct sockaddr_in);
	while(1){
		newsockfd=accept(sockfd,(struct sockaddr*)&cl_addr,(socklen_t*)&len);
		if(newsockfd<0){
			printf("Error accepting connection\n");
			exit(1);
		}
		inet_ntop(AF_INET,&(cl_addr.sin_addr),clientAddr,CLADDR_LEN);
		printf("Connection accepted from %s...\n",clientAddr);

		memset(buffer,0,BUF_SIZE);
		printf("emter your messages on by one and press return key!\n");

		cl_data.addr = cl_addr;
		cl_data.len = len;
		cl_data.newsockfd = &newsockfd;
		cl_data.s_host = (char *) malloc(sizeof(char)*strlen(host));
		strcpy(cl_data.s_host,host);
		puts(cl_data.s_host);

		ret=pthread_create(&rThread,NULL,reciveMessage,&cl_data);

		if(ret){
			printf("ERROR: Return Code from pthread_create() is %d\n",ret);
			exit(1);
		}
	}
	close(newsockfd);
	close(sockfd);
	pthread_exit(NULL);
exit (0);
}